"""Exploitability-style evaluation helpers.

Exploitability measures how much a policy can be exploited by a best-response
opponent. This provides a proxy metric for policy robustness.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Dict, List, Sequence, Any
import numpy as np


@dataclass
class ExploitabilityResult:
    """Result of exploitability evaluation."""

    policy_name: str
    opponent_scores: Dict[str, float]
    mean_score: float
    std_score: float
    worst_case_score: float
    best_case_score: float

    def to_dict(self) -> dict:
        return {
            "policy_name": self.policy_name,
            "opponent_scores": self.opponent_scores,
            "mean_score": self.mean_score,
            "std_score": self.std_score,
            "worst_case_score": self.worst_case_score,
            "best_case_score": self.best_case_score,
        }


def evaluate_against_checkpoints(
    policy,
    opponent_pool: Sequence,
    eval_fn: Callable,
    num_episodes: int = 10,
) -> Dict[str, float]:
    """Evaluate a policy against a pool of opponent checkpoints.

    Args:
        policy: The policy to evaluate.
        opponent_pool: Sequence of opponent policies (checkpoints).
        eval_fn: Function(policy, opponent) -> score.
        num_episodes: Episodes per opponent.

    Returns:
        Dictionary of scores per opponent plus aggregated statistics.
    """
    scores = {}
    all_scores = []

    for idx, opp in enumerate(opponent_pool):
        opponent_name = getattr(opp, "name", f"opponent_{idx}")
        episode_scores = []

        for _ in range(num_episodes):
            score = eval_fn(policy, opp)
            episode_scores.append(score)

        mean_score = np.mean(episode_scores)
        scores[opponent_name] = float(mean_score)
        all_scores.extend(episode_scores)

    if all_scores:
        scores["mean_score"] = float(np.mean(all_scores))
        scores["std_score"] = float(np.std(all_scores))
        scores["worst_case"] = float(np.min(all_scores))
        scores["best_case"] = float(np.max(all_scores))
    else:
        scores["mean_score"] = 0.0
        scores["std_score"] = 0.0
        scores["worst_case"] = 0.0
        scores["best_case"] = 0.0

    return scores


def evaluate_exploitability(
    policy,
    opponent_pool: Sequence,
    eval_fn: Callable,
    policy_name: str = "policy",
    num_episodes: int = 10,
) -> ExploitabilityResult:
    """Compute exploitability proxy for a policy.

    Exploitability is measured as the worst-case performance against
    a diverse set of opponents.

    Args:
        policy: The policy to evaluate.
        opponent_pool: Pool of diverse opponents.
        eval_fn: Evaluation function.
        policy_name: Name of the policy for reporting.
        num_episodes: Episodes per opponent.

    Returns:
        ExploitabilityResult with detailed scores.
    """
    scores = evaluate_against_checkpoints(policy, opponent_pool, eval_fn, num_episodes)

    opponent_scores = {
        k: v
        for k, v in scores.items()
        if k not in ["mean_score", "std_score", "worst_case", "best_case"]
    }

    return ExploitabilityResult(
        policy_name=policy_name,
        opponent_scores=opponent_scores,
        mean_score=scores.get("mean_score", 0.0),
        std_score=scores.get("std_score", 0.0),
        worst_case_score=scores.get("worst_case", 0.0),
        best_case_score=scores.get("best_case", 0.0),
    )


class HeuristicMrX:
    """Simple heuristic MrX policy for exploitability baseline.

    Strategy: Move to the node that maximizes distance from closest police.
    """

    def __init__(self, name: str = "HeuristicMrX"):
        self.name = name

    def select_action(self, observation: Dict[str, Any]) -> int:
        """Select action based on heuristic.

        Args:
            observation: Environment observation dict.

        Returns:
            Selected node index.
        """
        valid_actions = observation.get("valid_actions", [])
        if not valid_actions:
            return observation.get("agent_position", 0)

        police_positions = observation.get("Polices_pos", [])
        adjacency = observation.get("adjacency_matrix")

        if not police_positions or adjacency is None:
            return np.random.choice(valid_actions)

        # For each valid action, estimate distance to closest police
        best_action = valid_actions[0]
        best_min_distance = -1

        for action in valid_actions:
            min_dist = float("inf")
            for police_pos in police_positions:
                # Simple hop distance (could use weighted Dijkstra)
                dist = self._hop_distance(adjacency, action, police_pos)
                min_dist = min(min_dist, dist)

            if min_dist > best_min_distance:
                best_min_distance = min_dist
                best_action = action

        return best_action

    def _hop_distance(self, adjacency: np.ndarray, start: int, end: int) -> int:
        """BFS hop distance between two nodes."""
        if start == end:
            return 0

        n = adjacency.shape[0]
        visited = set([start])
        queue = [(start, 0)]

        while queue:
            node, dist = queue.pop(0)
            for neighbor in range(n):
                if adjacency[node, neighbor] > 0 and neighbor not in visited:
                    if neighbor == end:
                        return dist + 1
                    visited.add(neighbor)
                    queue.append((neighbor, dist + 1))

        return n  # Max distance if not connected


class HeuristicPolice:
    """Simple heuristic Police policy for exploitability baseline.

    Strategy: Move toward the last known or believed MrX position.
    """

    def __init__(self, name: str = "HeuristicPolice"):
        self.name = name

    def select_action(self, observation: Dict[str, Any]) -> int:
        """Select action based on heuristic.

        Args:
            observation: Environment observation dict.

        Returns:
            Selected node index.
        """
        valid_actions = observation.get("valid_actions", [])
        if not valid_actions:
            return observation.get("agent_position", 0)

        # Use belief map if available, otherwise use revealed position
        belief_map = observation.get("belief_map")
        mrx_revealed = observation.get("MrX_revealed")
        adjacency = observation.get("adjacency_matrix")

        if mrx_revealed is not None:
            target = mrx_revealed
        elif belief_map is not None:
            target = np.argmax(belief_map)
        else:
            # Random if no information
            return np.random.choice(valid_actions)

        if adjacency is None:
            return np.random.choice(valid_actions)

        # Move toward target
        best_action = valid_actions[0]
        best_distance = float("inf")

        for action in valid_actions:
            dist = self._hop_distance(adjacency, action, target)
            if dist < best_distance:
                best_distance = dist
                best_action = action

        return best_action

    def _hop_distance(self, adjacency: np.ndarray, start: int, end: int) -> int:
        """BFS hop distance between two nodes."""
        if start == end:
            return 0

        n = adjacency.shape[0]
        visited = set([start])
        queue = [(start, 0)]

        while queue:
            node, dist = queue.pop(0)
            for neighbor in range(n):
                if adjacency[node, neighbor] > 0 and neighbor not in visited:
                    if neighbor == end:
                        return dist + 1
                    visited.add(neighbor)
                    queue.append((neighbor, dist + 1))

        return n


def create_baseline_opponents(num_heuristic: int = 3) -> Dict[str, List]:
    """Create baseline opponent pools for exploitability evaluation.

    Args:
        num_heuristic: Number of heuristic variants.

    Returns:
        Dictionary with MrX and Police opponent pools.
    """
    mrx_pool = [HeuristicMrX(f"HeuristicMrX_{i}") for i in range(num_heuristic)]
    police_pool = [
        HeuristicPolice(f"HeuristicPolice_{i}") for i in range(num_heuristic)
    ]

    return {
        "MrX": mrx_pool,
        "Police": police_pool,
    }


def compute_exploitability_metrics(
    mrx_policy,
    police_policy,
    eval_fn: Callable,
    num_episodes: int = 20,
) -> Dict[str, float]:
    """Compute exploitability metrics for both policies.

    Args:
        mrx_policy: MrX policy to evaluate.
        police_policy: Police policy to evaluate.
        eval_fn: Evaluation function.
        num_episodes: Episodes per evaluation.

    Returns:
        Dictionary of exploitability metrics.
    """
    baselines = create_baseline_opponents()

    # Evaluate MrX against heuristic police
    mrx_result = evaluate_exploitability(
        mrx_policy, baselines["Police"], eval_fn, "MrX", num_episodes
    )

    # Evaluate Police against heuristic MrX
    police_result = evaluate_exploitability(
        police_policy, baselines["MrX"], eval_fn, "Police", num_episodes
    )

    return {
        "mrx_mean_vs_baseline": mrx_result.mean_score,
        "mrx_worst_case": mrx_result.worst_case_score,
        "police_mean_vs_baseline": police_result.mean_score,
        "police_worst_case": police_result.worst_case_score,
        "combined_exploitability": (
            mrx_result.worst_case_score + police_result.worst_case_score
        )
        / 2,
    }
